from lib import LIBRARY

TI_FALSE = u32(0)
TI_TRUE = u32(1)
TiBool = u32
TiFlags = u32
TI_NULL_HANDLE = 0
TiRuntime = Ptr[byte]
TiAotModule = Ptr[byte]
TiMemory = Ptr[byte]
TiImage = Ptr[byte]
TiSampler = Ptr[byte]
TiKernel = Ptr[byte]
TiComputeGraph = Ptr[byte]

# 定义类型别名  
TiError = u32  
  
# 定义枚举常量  
TI_ERROR_SUCCESS = TiError(0)  
TI_ERROR_NOT_SUPPORTED = TiError(-1)
TI_ERROR_CORRUPTED_DATA = TiError(-2)  
TI_ERROR_NAME_NOT_FOUND = TiError(-3)  
TI_ERROR_INVALID_ARGUMENT = TiError(-4)  
TI_ERROR_ARGUMENT_NULL = TiError(-5)
TI_ERROR_ARGUMENT_OUT_OF_RANGE = TiError(-6)
TI_ERROR_ARGUMENT_NOT_FOUND = TiError(-7)
TI_ERROR_INVALID_INTEROP = TiError(-8)
TI_ERROR_INVALID_STATE = TiError(-9)
TI_ERROR_INCOMPATIBLE_MODULE = TiError(-10)
TI_ERROR_OUT_OF_MEMORY = TiError(-11)
TI_ERROR_MAX_ENUM = TiError(0xFFFFFFFF)

TiArch = u32
TI_ARCH_RESERVED = TiArch(0)
# Vulkan GPU backend.
TI_ARCH_VULKAN = TiArch(1)
# Metal GPU backend.
TI_ARCH_METAL = TiArch(2)
# NVIDIA CUDA GPU backend.
TI_ARCH_CUDA = TiArch(3)
# x64 native CPU backend.
TI_ARCH_X64 = TiArch(4)
# Arm64 native CPU backend.
TI_ARCH_ARM64 = TiArch(5)
# OpenGL GPU backend.
TI_ARCH_OPENGL = TiArch(6)
# OpenGL ES GPU backend.
TI_ARCH_GLES = TiArch(7)
TI_ARCH_MAX_ENUM = TiArch(0xFFFFFFFF)

TiCapability = u32
TI_CAPABILITY_RESERVED = TiCapability(0)
TI_CAPABILITY_SPIRV_VERSION = TiCapability(1)
TI_CAPABILITY_SPIRV_HAS_INT8 = TiCapability(2)
TI_CAPABILITY_SPIRV_HAS_INT16 = TiCapability(3)
TI_CAPABILITY_SPIRV_HAS_INT64 = TiCapability(4)
TI_CAPABILITY_SPIRV_HAS_FLOAT16 = TiCapability(5)
TI_CAPABILITY_SPIRV_HAS_FLOAT64 = TiCapability(6)
TI_CAPABILITY_SPIRV_HAS_ATOMIC_INT64 = TiCapability(7)
TI_CAPABILITY_SPIRV_HAS_ATOMIC_FLOAT16 = TiCapability(8)
TI_CAPABILITY_SPIRV_HAS_ATOMIC_FLOAT16_ADD = TiCapability(9)
TI_CAPABILITY_SPIRV_HAS_ATOMIC_FLOAT16_MINMAX = TiCapability(10)
TI_CAPABILITY_SPIRV_HAS_ATOMIC_FLOAT = TiCapability(11)
TI_CAPABILITY_SPIRV_HAS_ATOMIC_FLOAT_ADD = TiCapability(12)
TI_CAPABILITY_SPIRV_HAS_ATOMIC_FLOAT_MINMAX = TiCapability(13)
TI_CAPABILITY_SPIRV_HAS_ATOMIC_FLOAT64 = TiCapability(14)
TI_CAPABILITY_SPIRV_HAS_ATOMIC_FLOAT64_ADD = TiCapability(15)
TI_CAPABILITY_SPIRV_HAS_ATOMIC_FLOAT64_MINMAX = TiCapability(16)
TI_CAPABILITY_SPIRV_HAS_VARIABLE_PTR = TiCapability(17)
TI_CAPABILITY_SPIRV_HAS_PHYSICAL_STORAGE_BUFFER = TiCapability(18)
TI_CAPABILITY_SPIRV_HAS_SUBGROUP_BASIC = TiCapability(19)
TI_CAPABILITY_SPIRV_HAS_SUBGROUP_VOTE = TiCapability(20)
TI_CAPABILITY_SPIRV_HAS_SUBGROUP_ARITHMETIC = TiCapability(21)
TI_CAPABILITY_SPIRV_HAS_SUBGROUP_BALLOT = TiCapability(22)
TI_CAPABILITY_SPIRV_HAS_NON_SEMANTIC_INFO = TiCapability(23)
TI_CAPABILITY_SPIRV_HAS_NO_INTEGER_WRAP_DECORATION = TiCapability(24)
TI_CAPABILITY_MAX_ENUM = TiCapability(0xFFFFFFFF)

class TiCapabilityLevelInfo:  
    capability: TiCapability  
    level: u32

TiDataType = u32
# 16-bit IEEE 754 half-precision floating-point number.
TI_DATA_TYPE_F16 = TiDataType(0)
# 32-bit IEEE 754 single-precision floating-point number.
TI_DATA_TYPE_F32 = TiDataType(1)
# 64-bit IEEE 754 double-precision floating-point number.
TI_DATA_TYPE_F64 = TiDataType(2)
# 8-bit one's complement signed integer.
TI_DATA_TYPE_I8 = TiDataType(3)
# 16-bit one's complement signed integer.
TI_DATA_TYPE_I16 = TiDataType(4)
# 32-bit one's complement signed integer.
TI_DATA_TYPE_I32 = TiDataType(5)
# 64-bit one's complement signed integer.
TI_DATA_TYPE_I64 = TiDataType(6)
TI_DATA_TYPE_U1 = TiDataType(7)
# 8-bit unsigned integer.
TI_DATA_TYPE_U8 = TiDataType(8)
# 16-bit unsigned integer.
TI_DATA_TYPE_U16 = TiDataType(9)
# 32-bit unsigned integer.
TI_DATA_TYPE_U32 = TiDataType(10)
# 64-bit unsigned integer.
TI_DATA_TYPE_U64 = TiDataType(11)
TI_DATA_TYPE_GEN = TiDataType(12)
TI_DATA_TYPE_UNKNOWN = TiDataType(13)
TI_DATA_TYPE_MAX_ENUM = TiDataType(0xFFFFFFFF)

TiArgumentType = u32
# 32-bit one's complement signed integer.
TI_ARGUMENT_TYPE_I32 = TiArgumentType(0)
# 32-bit IEEE 754 single-precision floating-point number.
TI_ARGUMENT_TYPE_F32 = TiArgumentType(1)
# ND-array wrapped around a `handle.memory`.
TI_ARGUMENT_TYPE_NDARRAY = TiArgumentType(2)
# Texture wrapped around a `handle.image`.
TI_ARGUMENT_TYPE_TEXTURE = TiArgumentType(3)
# Typed scalar.
TI_ARGUMENT_TYPE_SCALAR = TiArgumentType(4)
# Typed tensor.
TI_ARGUMENT_TYPE_TENSOR = TiArgumentType(5)
TI_ARGUMENT_TYPE_MAX_ENUM = TiArgumentType(0xFFFFFFFF)

TiMemoryUsageFlags = TiFlags
TiMemoryUsageFlagBits = u32
# The memory can be read/write accessed by any kernel.
TI_MEMORY_USAGE_STORAGE_BIT = TiMemoryUsageFlagBits(1 << 0)
# The memory can be used as a uniform buffer in graphics pipelines.
TI_MEMORY_USAGE_UNIFORM_BIT = TiMemoryUsageFlagBits(1 << 1)
# The memory can be used as a vertex buffer in graphics pipelines.
TI_MEMORY_USAGE_VERTEX_BIT = TiMemoryUsageFlagBits(1 << 2)
# The memory can be used as an index buffer in graphics pipelines.
TI_MEMORY_USAGE_INDEX_BIT = TiMemoryUsageFlagBits(1 << 3)

class TiMemoryAllocateInfo:  
    size: u64
    host_write: TiBool  
    host_read: TiBool  
    export_sharing: TiBool  
    usage: TiMemoryUsageFlags

class TiMemorySlice:
    memory: TiMemory
    offset: u64
    size: u64

@tuple  
class TiNdShape:  
    dim_count: u32  
    dims: tuple[u32, u32, u32, u32, u32, u32, u32, u32,
                   u32, u32, u32, u32, u32, u32, u32, u32]

@tuple
class TiNdArray:
    memory: TiMemory
    shape: TiNdShape
    elem_shape: TiNdShape
    elem_type: TiDataType

TiImageUsageFlags = TiFlags
TiImageUsageFlagBits = u32
# The image can be read/write accessed by any kernel.
TI_IMAGE_USAGE_STORAGE_BIT = TiImageUsageFlagBits(1 << 0)
# The image can be read-only accessed by any kernel.
TI_IMAGE_USAGE_SAMPLED_BIT = TiImageUsageFlagBits(1 << 1)
# The image can be used as a color or depth-stencil attachment depending on its format.
TI_IMAGE_USAGE_ATTACHMENT_BIT = TiImageUsageFlagBits(1 << 2)

TiImageDimension = u32
# The image is 1-dimensional.
TI_IMAGE_DIMENSION_1D = TiImageDimension(0)
# The image is 2-dimensional.
TI_IMAGE_DIMENSION_2D = TiImageDimension(1)
# The image is 3-dimensional.
TI_IMAGE_DIMENSION_3D = TiImageDimension(2)
# The image is 1-dimensional and it has one or more layers.
TI_IMAGE_DIMENSION_1D_ARRAY = TiImageDimension(3)
# The image is 2-dimensional and it has one or more layers.
TI_IMAGE_DIMENSION_2D_ARRAY = TiImageDimension(4)
# The image is 2-dimensional and it has 6 layers for the faces towards +X, -X, +Y, -Y, +Z, -Z in sequence.
TI_IMAGE_DIMENSION_CUBE = TiImageDimension(5)
TI_IMAGE_DIMENSION_MAX_ENUM = TiImageDimension(0xFFFFFFFF)


TiImageLayout = u32
# Undefined layout. An image in this layout does not contain any semantical information.
TI_IMAGE_LAYOUT_UNDEFINED = TiImageLayout(0)
# Optimal layout for read-only access, including sampling.
TI_IMAGE_LAYOUT_SHADER_READ = TiImageLayout(1)
# Optimal layout for write-only access.
TI_IMAGE_LAYOUT_SHADER_WRITE = TiImageLayout(2)
# Optimal layout for read/write access.
TI_IMAGE_LAYOUT_SHADER_READ_WRITE = TiImageLayout(3)
# Optimal layout as a color attachment.
TI_IMAGE_LAYOUT_COLOR_ATTACHMENT = TiImageLayout(4)
# Optimal layout as an input color attachment.
TI_IMAGE_LAYOUT_COLOR_ATTACHMENT_READ = TiImageLayout(5)
# Optimal layout as a depth attachment.
TI_IMAGE_LAYOUT_DEPTH_ATTACHMENT = TiImageLayout(6)
# Optimal layout as an input depth attachment.
TI_IMAGE_LAYOUT_DEPTH_ATTACHMENT_READ = TiImageLayout(7)
# Optimal layout as a data copy destination.
TI_IMAGE_LAYOUT_TRANSFER_DST = TiImageLayout(8)
# Optimal layout as a data copy source.
TI_IMAGE_LAYOUT_TRANSFER_SRC = TiImageLayout(9)
# Optimal layout as a presentation source.
TI_IMAGE_LAYOUT_PRESENT_SRC = TiImageLayout(10)
TI_IMAGE_LAYOUT_MAX_ENUM = TiImageLayout(0xFFFFFFFF)

TiFormat = u32
TI_FORMAT_UNKNOWN = TiFormat(0)
TI_FORMAT_R8 = TiFormat(1)
TI_FORMAT_RG8 = TiFormat(2)
TI_FORMAT_RGBA8 = TiFormat(3)
TI_FORMAT_RGBA8SRGB = TiFormat(4)
TI_FORMAT_BGRA8 = TiFormat(5)
TI_FORMAT_BGRA8SRGB = TiFormat(6)
TI_FORMAT_R8U = TiFormat(7)
TI_FORMAT_RG8U = TiFormat(8)
TI_FORMAT_RGBA8U = TiFormat(9)
TI_FORMAT_R8I = TiFormat(10)
TI_FORMAT_RG8I = TiFormat(11)
TI_FORMAT_RGBA8I = TiFormat(12)
TI_FORMAT_R16 = TiFormat(13)
TI_FORMAT_RG16 = TiFormat(14)
TI_FORMAT_RGB16 = TiFormat(15)
TI_FORMAT_RGBA16 = TiFormat(16)
TI_FORMAT_R16U = TiFormat(17)
TI_FORMAT_RG16U = TiFormat(18)
TI_FORMAT_RGB16U = TiFormat(19)
TI_FORMAT_RGBA16U = TiFormat(20)
TI_FORMAT_R16I = TiFormat(21)
TI_FORMAT_RG16I = TiFormat(22)
TI_FORMAT_RGB16I = TiFormat(23)
TI_FORMAT_RGBA16I = TiFormat(24)
TI_FORMAT_R16F = TiFormat(25)
TI_FORMAT_RG16F = TiFormat(26)
TI_FORMAT_RGB16F = TiFormat(27)
TI_FORMAT_RGBA16F = TiFormat(28)
TI_FORMAT_R32U = TiFormat(29)
TI_FORMAT_RG32U = TiFormat(30)
TI_FORMAT_RGB32U = TiFormat(31)
TI_FORMAT_RGBA32U = TiFormat(32)
TI_FORMAT_R32I = TiFormat(33)
TI_FORMAT_RG32I = TiFormat(34)
TI_FORMAT_RGB32I = TiFormat(35)
TI_FORMAT_RGBA32I = TiFormat(36)
TI_FORMAT_R32F = TiFormat(37)
TI_FORMAT_RG32F = TiFormat(38)
TI_FORMAT_RGB32F = TiFormat(39)
TI_FORMAT_RGBA32F = TiFormat(40)
TI_FORMAT_DEPTH16 = TiFormat(41)
TI_FORMAT_DEPTH24STENCIL8 = TiFormat(42)
TI_FORMAT_DEPTH32F = TiFormat(43)
TI_FORMAT_MAX_ENUM = TiFormat(0xFFFFFFFF)

class TiImageOffset:
    x: u32
    y: u32
    z: u32
    array_layer_offset: u32

class TiImageExtent:
    width: u32
    height: u32
    depth: u32
    array_layer_count: u32

class TiImageAllocateInfo:
    dimension: TiImageDimension
    extent: TiImageExtent
    mip_level_count: u32
    format: TiFormat
    export_sharing: TiBool
    usage: TiImageUsageFlags

class TiImageSlice:
    image: TiImage
    offset: TiImageOffset
    extent: TiImageExtent
    mip_level: u32

TiFilter = u32
TI_FILTER_NEAREST = TiFilter(0)
TI_FILTER_LINEAR = TiFilter(1)
TI_FILTER_MAX_ENUM = TiFilter(0xFFFFFFFF)

TiAddressMode = u32
TI_ADDRESS_MODE_REPEAT = TiAddressMode(0)
TI_ADDRESS_MODE_MIRRORED_REPEAT = TiAddressMode(1)
TI_ADDRESS_MODE_CLAMP_TO_EDGE = TiAddressMode(2)
TI_ADDRESS_MODE_MAX_ENUM = TiAddressMode(0xFFFFFFFF)

class TiSamplerCreateInfo:  
    mag_filter: TiFilter  
    min_filter: TiFilter  
    address_mode: TiAddressMode  
    max_anisotropy: float32

class TiTexture:  
    image: TiImage  
    sampler: TiSampler  
    dimension: TiImageDimension  
    extent: TiImageExtent  
    format: TiFormat

from typing import Union  
  
TiScalarValue = Union[u8, u16, u32, u64]
TiTensorValue = Union[Ptr[u8], Ptr[u16], Ptr[u32], Ptr[u64]]

@tuple
class TiScalar:  
    value: TiScalarValue
    type: TiDataType

@tuple
class TiTensorValueWithLength:
    length: u32
    data: TiTensorValue

@tuple
class TiTensor:
    type: TiDataType
    contents: TiTensorValueWithLength

@tuple
class TiArgumentValue:
    i32: i32
    f32: float32
    ndarray: TiNdArray
    

@tuple
class TiArgument:
    type: TiArgumentType
    value: TiArgumentValue

class TiNamedArgument:
    name: Ptr[byte]
    value: Ptr[byte]

def ti_get_version() -> u32:
    from C import LIBRARY.ti_get_version() -> u32
    out = ti_get_version()
    return out

def ti_get_last_error(
    message_size: Ptr[u64],
    message: Ptr[byte]
) -> TiError:
    from C import LIBRARY.ti_get_last_error(Ptr[u64], Ptr[byte]) -> TiError
    out = ti_get_last_error(message_size, message)
    return TiError(out)

def ti_set_last_error(
    error: TiError,
    message: Ptr[byte],
) -> None:
    from C import LIBRARY.ti_set_last_error(TiError, Ptr[byte]) -> None
    ti_set_last_error(error, message)

def ti_create_runtime(
    arch: TiArch,
    device_index: u32,
) -> TiRuntime:
    from C import LIBRARY.ti_create_runtime(TiArch, u32) -> TiRuntime
    out = ti_create_runtime(arch, device_index)
    return TiRuntime(out)

def ti_destroy_runtime(
    runtime: TiRuntime,
) -> None:
    from C import LIBRARY.ti_destroy_runtime(TiRuntime) -> None
    ti_destroy_runtime(runtime)

def ti_set_runtime_capabilities_ext(
    runtime: TiRuntime,
    capability_count: u32,
    capabilities: Ptr[byte],
) -> None:
    from C import LIBRARY.ti_set_runtime_capabilities_ext(TiRuntime, u32, Ptr[byte]) -> None
    ti_set_runtime_capabilities_ext(runtime, capability_count, capabilities)

def ti_get_runtime_capabilities(
    runtime: TiRuntime,
    capability_count: Ptr[u32],
    capabilities: Ptr[byte],
) -> u32:
    from C import LIBRARY.ti_get_runtime_capabilities(TiRuntime, Ptr[u32], Ptr[byte]) -> u32
    return ti_get_runtime_capabilities(runtime, capability_count, capabilities)

def ti_allocate_memory(
    runtime: TiRuntime,
    allocate_info: Ptr[byte]
) -> TiMemory:
    from C import LIBRARY.ti_allocate_memory(TiRuntime, Ptr[byte]) -> TiMemory
    out = ti_allocate_memory(runtime, allocate_info)
    return TiMemory(out)

def ti_free_memory(
    runtime: TiRuntime,
    memory: TiMemory,
) -> None:
    from C import LIBRARY.ti_free_memory(TiRuntime, TiMemory) -> None
    ti_free_memory(runtime, memory)

def ti_map_memory(
    runtime: TiRuntime,
    memory: TiMemory,
) -> Ptr[byte]:
    from C import LIBRARY.ti_map_memory(TiRuntime, TiMemory) -> Ptr[byte]
    out = ti_map_memory(runtime, memory)
    return out

def ti_unmap_memory(
    runtime: TiRuntime,
    memory: TiMemory,
) -> None:
    from C import LIBRARY.ti_unmap_memory(TiRuntime, TiMemory) -> None
    ti_unmap_memory(runtime, memory)

def ti_allocate_image(
    runtime: TiRuntime,
    allocate_info: Ptr[byte]
) -> TiImage:
    from C import LIBRARY.ti_allocate_image(TiRuntime, Ptr[byte]) -> TiImage
    out = ti_allocate_image(runtime, allocate_info)
    return TiImage(out)

def ti_free_image(
    runtime: TiRuntime,
    image: TiImage,
) -> None:
    from C import LIBRARY.ti_free_image(TiRuntime, TiImage) -> None
    ti_free_image(runtime, image)

def ti_create_sampler(
    runtime: TiRuntime,
    create_info: Ptr[byte]
) -> TiSampler:
    from C import LIBRARY.ti_create_sampler(TiRuntime, Ptr[byte]) -> TiSampler
    out = ti_create_sampler(runtime, create_info)
    return TiSampler(out)

def ti_destroy_sampler(
    runtime: TiRuntime,
    sampler: TiSampler
) -> None:
    from C import LIBRARY.ti_destroy_sampler(TiRuntime, TiSampler) -> None
    ti_destroy_sampler(runtime, sampler)

def ti_copy_memory_device_to_device(
    runtime: TiRuntime,
    dst_memory: Ptr[byte],
    src_memory: Ptr[byte],
) -> None:
    from C import LIBRARY.ti_copy_memory_device_to_device(TiRuntime, Ptr[byte], Ptr[byte]) -> None
    ti_copy_memory_device_to_device(runtime, dst_memory, src_memory)

def ti_track_image_ext(
    runtime: TiRuntime,
    image: TiImage,
    layout: TiImageLayout,
) -> None:
    from C import LIBRARY.ti_track_image_ext(TiRuntime, TiImage, TiImageLayout) -> None
    ti_track_image_ext(runtime, image, layout)

def ti_transition_image(
    runtime: TiRuntime,
    image: TiImage,
    layout: TiImageLayout,
) -> None:
    from C import LIBRARY.ti_transition_image(TiRuntime, TiImage, TiImageLayout) -> None
    ti_transition_image(runtime, image, layout)

#TODO,fix this，支持可以return的kernel
def ti_launch_kernel(
    runtime: TiRuntime,
    kernel: TiKernel,
    arg_count: u32,
    args: Ptr[TiArgument]
) -> None:
    from C import LIBRARY.ti_launch_kernel(TiRuntime, TiKernel, u32, Ptr[TiArgument]) -> None
    ti_launch_kernel(runtime, kernel, arg_count, args)

def ti_launch_compute_graph(
    runtime: TiRuntime,
    compute_graph: TiComputeGraph,
    arg_count: u32,
    args: Ptr[byte]
) -> None:
    from C import LIBRARY.ti_launch_compute_graph(TiRuntime, TiComputeGraph, u32, Ptr[byte]) -> None
    ti_launch_compute_graph(runtime, compute_graph, arg_count, args)

def ti_flush(
    runtime: TiRuntime,
) -> None:
    from C import LIBRARY.ti_flush(TiRuntime) -> None
    ti_flush(runtime)

def ti_wait(
    runtime: TiRuntime,
) -> None:
    from C import LIBRARY.ti_wait(TiRuntime) -> None
    ti_wait(runtime)

def ti_load_aot_module(
    runtime: TiRuntime,
    module_path: Ptr[byte],
) -> TiAotModule:
    from C import LIBRARY.ti_load_aot_module(TiRuntime, Ptr[byte]) -> TiAotModule
    out = ti_load_aot_module(runtime, module_path)
    return TiAotModule(out)

def ti_create_aot_module(
    runtime: TiRuntime,
    tcm: Ptr[byte],
    size: u64,
) -> TiAotModule:
    from C import LIBRARY.ti_create_aot_module(TiRuntime, Ptr[byte], u64) -> TiAotModule
    out = ti_create_aot_module(runtime, tcm, size)

def ti_destroy_aot_module(
    module: TiAotModule,
) -> None:
    from C import LIBRARY.ti_destroy_aot_module(TiAotModule)
    ti_destroy_aot_module(module)

def ti_get_aot_module_kernel(
    aot_module: TiAotModule,
    name: Ptr[byte],
) -> TiKernel:
    from C import LIBRARY.ti_get_aot_module_kernel(TiAotModule, Ptr[byte]) -> TiKernel
    out = ti_get_aot_module_kernel(aot_module, name)
    return TiKernel(out)

def ti_get_aot_module_compute_graph(
    aot_module: TiAotModule,
    name: Ptr[byte],
) -> TiComputeGraph:
    from C import LIBRARY.ti_get_aot_module_compute_graph(TiAotModule, Ptr[byte]) -> TiComputeGraph
    out = ti_get_aot_module_compute_graph(aot_module, name)
    return TiComputeGraph(out)
